Week 11 - Module Review
Dr Lucas Fran√ßa
Today's Session
Purpose:

Consolidate learning and connect to your assessment
Core GA concepts recap
Key encoding strategies
Assessment-specific guidance
Week-by-week summary

Goal: Connect theory to practice and prepare you for successful completion of the cargo container loading assignment

Part 1: The GA Essentials
The Universal GA Pattern
Every GA follows this structure:
python# 1. Initialize random population
population = create_random_individuals(pop_size)

# 2. Main evolutionary loop
for generation in range(max_generations):
    # Evaluate fitness
    for individual in population:
        individual.fitness = evaluate(individual)
    
    # Check for solution
    if found_solution(population):
        return best_solution(population)
    
    # Create next generation
    new_population = []
    for i in range(pop_size):
        parent_a = select_parent(population)
        parent_b = select_parent(population)
        child = crossover(parent_a, parent_b)
        child = mutate(child)
        new_population.append(child)
    population = new_population
```

### Five Critical Design Decisions

1. **üß¨ Encoding** ‚Äì How to represent solutions?
   - Direct vs indirect
   - Binary, integer, permutation, order-based
   - Determines search space size

2. **ü¶ï Fitness Function** ‚Äì How to measure quality?
   - Must provide gradient for improvement
   - Handle constraints with penalties
   - Fast to compute (called thousands of times)

3. **üîÄ Selection** ‚Äì How to choose parents?
   - Tournament selection (recommended)
   - Balance exploration vs exploitation

4. **üßë‚Äçüßë‚Äçüßí Genetic Operators** ‚Äì How to create offspring?
   - Crossover: combine parent solutions
   - Mutation: introduce variation
   - Must respect encoding constraints

5. **üõ†Ô∏è Parameters** ‚Äì Population size, mutation rate, generations
   - No universal best settings
   - Always experiment and tune
   - Problem-dependent

**Remember:** There are no "magic" parameter values ‚Äì you must experiment!

---

## Part 2: Encoding Strategies

### Encoding Comparison

| Type | When to Use | Search Space | Operators | Example |
|------|-------------|--------------|-----------|---------|
| Binary | Selection problems | 2^n | Standard | Knapsack: [1,0,1,1] |
| Integer | Multi-state | k^n | Standard | Graph colouring: [2,3,1,2] |
| Permutation | Ordering | n! | OX, swap | TSP: [3,1,4,2,5] |
| Order-based | Sequential construction | n! | OX, swap | Circle packing: [C,D,A,B] |

**Key Insight:** Order-based encoding dramatically reduces search space whilst ensuring all solutions are valid!

### Why Order-Based?

**Direct coordinate encoding problems:**
- Search space: positions^n (enormous!)
- Most solutions invalid (overlapping cylinders)
- Hard to handle constraints

**Order-based encoding benefits:**
- Search space: n! (much smaller)
- All solutions valid (placement algorithm ensures it)
- Constraints handled by placement logic
- Proven approach from circle packing

**Structure:** Genome = ordering ‚û°Ô∏è Placement algorithm ‚û°Ô∏è Valid solution

### Key Operators for Permutations

**Ordered Crossover (OX):**
```
Parent 1: I E H [D G C F B] J A
Parent 2: A B C D E F G H I J

Child:    A E H [D G C F B] I J
```
- Preserves subsequence from Parent 1
- Fills remaining from Parent 2 in order
- Maintains validity (each element once)

**Swap Mutation:**
```
Before:  [A B C D E F]
              ‚Üï     ‚Üï
After:   [A E C D B F]

Swap two random positions
Simple and effective
Always maintains validity


Part 3: Fitness & Selection
Fitness Function Design
Must provide:

Meaningful gradient (reward improvements)
Constraint handling (penalties for violations)
Efficient computation
Appropriate scale

Constraint penalty example:
pythondef calculate_fitness(solution, container):
    # Check constraints with penalties
    if violates_geometric_constraints(solution):
        return -1000  # Large penalty
    if total_weight > max_weight:
        return -100 * (total_weight - max_weight)
    if centre_of_mass_invalid(solution):
        return -10 * distance_from_valid_region
    
    # All constraints satisfied: maximize utilization
    return calculate_space_utilization(solution)
Tournament Selection
Why tournament selection?

Works naturally with minimisation
No fitness scaling needed
Tunable selection pressure
Recommended for your assessment

pythondef tournament_selection(population, tournament_size=5):
    # Randomly sample individuals
    tournament = random.sample(population, tournament_size)
    # Return best (lowest fitness for minimisation)
    return min(tournament, key=lambda x: x.fitness)
Parameter tuning:

Small size (2-3): weaker pressure, more diversity
Medium size (5): balanced (recommended starting point)
Large size (7-10): stronger pressure, faster convergence


Part 4: Assessment Guidance
Your Cargo Container Problem
Combines concepts from:

Knapsack (weight constraint)
Circle packing (geometric placement)
TSP (ordering matters)

Key constraints:

Geometric: cylinders fit in rectangle
Weight capacity: total weight limit
Weight distribution: centre of mass in central 60%
Loading order: rear to front, no rearrangement

Objectives:

Minimize wasted space
Maximize number of cylinders loaded
Satisfy all constraints

Recommended Implementation Approach
Phase 1: Baseline Algorithms
python# 1. Random algorithm - verification baseline
def random_algorithm(cylinders, container, max_attempts):
    best = None
    for _ in range(max_attempts):
        ordering = random.shuffle(cylinders)
        solution = place_cylinders(ordering, container)
        if is_better(solution, best):
            best = solution
    return best

# 2. Greedy algorithm - comparison baseline
def greedy_algorithm(cylinders, container):
    # Sort by size (largest first) or other heuristic
    ordered = sorted(cylinders, key=lambda c: c.radius, reverse=True)
    return place_cylinders(ordered, container)
Phase 2: Genetic Algorithm
pythonclass Individual:
    def __init__(self, num_cylinders):
        # Order-based encoding
        self.ordering = list(range(num_cylinders))
        random.shuffle(self.ordering)
    
    def evaluate(self, cylinders, container):
        # Place cylinders sequentially (your local search)
        placed = []
        for cyl_id in self.ordering:
            position = find_valid_position(
                cylinders[cyl_id], placed, container
            )
            if position:
                placed.append((cylinders[cyl_id], position))
        
        # Calculate fitness with constraint penalties
        self.fitness = calculate_fitness(placed, container)
Critical Implementation Tips
‚úÖ Do:

Use order-based encoding (permutation of cylinder indices)
Implement tournament selection
Use OX crossover and swap mutation
Start with greedy algorithm as baseline
Test on simple instances first
Commit to GitHub regularly
Document your design decisions

‚ùå Don't:

Use direct coordinate encoding (search space too large)
Use fitness-proportionate selection (tournament is better)
Use standard crossover on permutations (breaks validity)
Skip baseline implementations
Wait until last minute

Common Pitfalls & Solutions
ProblemLikely CauseSolutionNo improvement over generationsFitness function lacks gradientCheck penalties are proportionalGA worse than randomImplementation bugVerify operators, test componentsSolutions invalidPlacement algorithm errorCheck geometric constraints carefullyPremature convergenceMutation rate too lowIncrease to 0.01-0.02Unstable performanceMutation rate too highDecrease to 0.005-0.01
Debug Strategy: Test each component separately before integrating into full GA

Part 5: Week-by-Week Summary
Module Learning Outcomes
WeekTopicKey Learning/Skill1Module Overview & ProblemsNP-completeness, exponential search spaces2Random & Greedy SearchBaseline algorithms, comparison methodology3Introduction to GAsGA cycle, fitness functions, basic operators43-Colouring ProblemInteger encoding, fitness-proportionate selection5Travelling SalespersonPermutation encoding, OX crossover, tournament selection7Circle PackingOrder-based encoding, memetic algorithms, search space reduction8Knapsack ProblemBinary encoding, penalty functions, constraint handling9Maze SolverIndirect encoding, local optima, parameter tuning
Core Skills You've Developed
Technical Skills:

Design appropriate encodings for problem structure
Implement complete GA systems in Python
Tune parameters experimentally
Compare algorithms fairly and rigorously
Handle constraints with penalties

Conceptual Understanding:

Transform real-world problems into computational problems
Analyse search space complexity
Apply evolutionary principles to optimization
Combine GAs with local search (memetic algorithms)
Evaluate when GAs are (and aren't) appropriate


Key Takeaways
Essential Principles

Encoding is critical ‚Äì Often most important design decision. Choose encoding that minimizes search space. Order-based + placement for sequential construction.
Fitness must provide gradient ‚Äì Reward small improvements. Use proportional penalties for constraints. Balance multiple objectives carefully.
Selection balances exploration/exploitation ‚Äì Tournament selection recommended. Size controls selection pressure. Start with size 5, adjust as needed.
Operators must respect encoding ‚Äì Permutations need OX and swap mutation. Standard operators break validity. Test that operators maintain constraints.
Parameters are problem-dependent ‚Äì Population: 100-500 for ordering problems. Mutation rate: 0.01-0.02 starting point. Always experiment and tune.
Baselines are essential ‚Äì Random verifies setup. Greedy provides comparison. If GA isn't better, investigate why.


Questions & Support
Getting Help:

Office hours: Wednesday 10-11am (ELB1.10)
Email: [email protected]
Workshop sessions (bring your code!)

Resources:

All lecture materials on Blackboard
Circle packing example code
Assessment brief and rubric
Reference test instances

Remember: Start early, test incrementally, commit to GitHub regularly, and ask for help when stuck!

Final Advice - Success Strategy

Understand the problem thoroughly
Implement baselines first (random, greedy)
Design your order-based encoding carefully
Build placement algorithm step-by-step
Test components individually
Tune parameters systematically
Compare algorithms fairly
Document everything clearly

You've learned all the concepts you need. Now apply them systematically!


Key Constraints:
Geometric constraint: All cylinders must fit within the rectangular container
boundaries
Weight distribution: The centre of mass of all loaded items must fall within the central
60% of the container (to prevent tipping during transport).
Weight limit: Total weight cannot exceed the container's maximum capacity.
Loading order: Cylinders are loaded from the rear and cannot be moved once placed.

Part 2 (70%)
IMPORTANT: To make it easier assess the development of your solution, please
store your code on a GitHub repository. I would like to see commits over the
semester that demonstrate how your solution evolved. This evidence helps to
confirm that your code was developed by you.
The implementation of your code accounts for 40% of the marks available. You must
implement your designed solution using an evolutionary algorithm written in Python
Processing library, a framework for which will be introduced in lectures and labs during
the first few weeks of term. You will be supplied with a number of simple reference
problem instances of the problem on which your code must be run in order to
benchmark the effectiveness of your algorithm(s). 
In order to gain a passing (40%+) mark for this component, your evolutionary code
must generate at least one solution that perfectly solves every reference instance (i.e.,
finds a fitness value of zero and perfectly packs every rectangular container with the
cylindrical containers). Your report must clearly state the solution found (the ordering
of the crates placed in the container) for each instance.
For the 60%+ mark band for this component, you must include visualisation of the
solutions generated. Please ensure you use the visualisation code supplied in
Week 7, as this will ensure consistency, and make it easier for me to verify the
correctness of the solutions you generate.
You will also be given a set of more challenging problem instances. For the 70%+ mark
band for this component, your code must pass on all these instances (again, finding a
perfect packing). As before, your report must clearly state the solution found for
each instance.
For the higher (80%+) mark band for this component, you must also provide
implementations of at least two other algorithms for the problem.
For the top (90%+) mark band for this component, you should provide the facility to
compare the best solutions found by your algorithms by ‚Äúflipping‚Äù through their
visualisations.
